\capitulo{4}{Técnicas y herramientas}


\section{Herramientas}

Se muestra a continuación las herramientas usadas a lo largo del desarrollo del proyecto.

\subsection{React Native}

La elección del framework adecuado juega un papel crucial en el éxito de un proyecto. Dicha elección se complica aún más cuando se carece de experiencia previa en el desarrollo de aplicaciones móviles. Dentro del gran abanico de posibilidades React Native y Flutter emergen como grandes líderes en el sector gracias a sus grandes comunidades y la abundancia de recursos en línea. Por otro lado se pueden descartar directamente opciones como el entorno de desarrollo de iOS(por ejemplo, el uso de Swift y Cocoa Touch) debido a su exclusividad para aplicaciones para iOS debido a que el objetivo de este proyecto es desarrollar una aplicación para Android.

React Native se presenta como mi elección favorita, este es un framework de código abierto creado por Facebook orientado a la creación de aplicaciones nativas tanto en iOS como en Android. React Native esta basado en JavaScript y React, una biblioteca de JavaScript destinada a la creación de interfaces de usuario. Fue lanzado en 2015 con el propósito de superar las limitaciones del desarrollo de aplicaciones móviles basado solo en HTML5, en las que simplemente se adapta aplicaciones web a un entorno móvil. React Native utiliza componentes nativos en lugar de WebViews para la interfaz de usuario, esto conlleva a que las aplicaciones se sientan y actúen como en una aplicación nativa.
Uno de los elementos mas importantes de este framework es el "React Native Bridge", el cual facilita la comunicación entre el código JavaScript y los elementos nativos del dispositivos. El puente maneja de forma paralela dos flujos de trabajo, uno ejecuta la lógica de la aplicación en JavaScript y otro gestiona las operaciones de la interfaz de usuario nativa. Esto permite que las aplicaciones en React Native accedan a las características del dispositivo como la cámara o la ubicación, ofreciendo una experiencia fluida para el usuario gracias a características como el "hot reload"

\imagen{puenteRN}{Flujo de trabajo y arquitectura de una aplicación React Native}{1}

Mi preferencia de este framework sobre el resto radica en mi familiaridad previa con la programación web y JavaScript, lo cual reducirá la curva de aprendizaje en la transición hacia React Native en contraste con otros frameworks que podrían requerir el aprendizaje de nuevos lenguajes de programación o paradigmas de programación. 
Por otro lado, uno de los grandes motivos de este framework es su gran popularidad, el cual se traduce en una gran riqueza de recursos disponibles, como bibliotecas, videotutoriales o foros, cruciales a la hora de enfrentar los desafíos que puedan surgir. 
Finalmente aunque para este proyecto no sea un requerimiento hay que tener en cuenta la gran versatilidad de React Native, el cual permite la creación de aplicaciones nativas tanto en Android como en iOS a partir de un único código base. Optimizando así el proceso de desarrollo permitiendo en un futuro poder dar cobertura a un mercado más amplio sin esfuerzos duplicados.

Como había nombrado anteriormente Flutter es otro framework que destaca sobre el resto y ofrece ciertas ventajas notables sobre React Native, como un rendimiento superior gracias al uso de su motor de renderizado propio y la gran capacidad de personalización de la interfaz de usuario. Aunque Flutter pudiera ser superior en algunos aspectos técnicos sigo decantándome por React Native debido a su gran comunidad y la familiaridad que tengo con las tecnologías web, priorizando así un aprendizaje más sencillo frente a posibles mejoras en el rendimiento. Por otro lado existen los frameworks Ionic y Xamarin que los he descartado debido a sus limitaciones en términos de acceso a funciones nativas y comunidades bastante inferiores comparado con React Native o Flutter. Kotlin era un opción con gran potencial para el desarrollo nativo de aplicaciones Android pero la descarté rápidamente por tener una curva de aprendizaje más pronunciada que su competencia, ya que representaría un obstáculo significativo en cuanto al tiempo de desarrollo sin garantizar beneficios proporcionales a dicho esfuerzo.

Respecto a Angular, si bien este framework ofrece un ecosistema robusto para el desarrollo de aplicaciones web dinámicas y complejas utilizando TypeScript, es importante mencionar que también es posible desarrollar aplicaciones móviles con Angular, ofreciendo una experiencia cercana a la nativa, aunque a través de un enfoque diferente al de las aplicaciones nativas desarrolladas con React Native. 
Angular no deja de ser una elección excelente, pero debido a la preferencia del proyecto de enfocarse en una aplicación móvil sin la necesidad de dar soporte de navegador, Angular puede no ser la opción más adecuada para el proyecto.
Por lo tanto he descartado Angular buscando una solución más enfocada y optimizada para el desarrollo móvil, aprovechando las capacidades nativas de los dispositivos móviles.


\subsection{Expo}

Expo es un framework que simplifica el desarrollo de aplicaciones móviles con React Native, actuando como una capa de abstracción reduciendo las barreras de entrada al desarrollo móvil. 
Consta de un entorno y herramientas listas para usar, eliminando la necesidad de configurar sistemas de construcción nativos complejos. 
Ofrece un conjunto de APIs disponibles a través de módulos que se pueden invocar directamente desde el código JavaScript las cuales cubren funcionalidades comunes del dispositivo, como cámara, geolocalización o notificaciones sin requerir de configuración adicional. 

Expo ha sido fundamental en el proyecto para desarrollar la interfaz de usuario permitiendo probar y visualizar cambios en tiempo real en diferentes plataformas.
Una de las funcionalidades significativas de Expo ha sido su capacidad para facilitar la ejecución y testeo de la aplicación directamente en dispositivos móviles personales sin necesidad de configurar emuladores. Esto se logra mediante el uso de la aplicación ExpoGo en el teléfono móvil y escaneando un código QR generado por el entorno de desarrollo Expo.
Expo ha tenido un papel fundamental en las fases de prueba y depuración, permitiendo probar la aplicación en un entorno real y ajustar la interfaz de usuario con un ciclo de retroalimentación casi instantáneo.


\subsection{Solidity}

Solidity es un lenguaje de programación de contratos orientado a objetos y de alto nivel diseñado específicamente para escribir Smart Contracts que se ejecutan en la Ethereum Virtual Machine (EVM). Consta de una sintaxis que recuerda a lenguajes como JavaScript, C++ o Python, lo que facilita su aprendizaje. 
Es un lenguaje de tipado estático, asegurando que el tipo de cada variable se define en tiempo de compilación y no cambia durante al ejecución del contrato, aumentando así la seguridad y ayudando a la detección de errores antes de la ejecución.

Una de las características más destacadas de Solidity es su soporte para la herencia, una característica común en la programación orientada a objetos. Esto permite que los Smart Contracts hereden propiedades y comportamientos de otros contratos, beneficiándose de la reutilización de código y la organización de la lógica del mismo. En mi caso ha sido de gran utilidad para implementar las funcionalidades del estándar ERC-721 utilizando la biblioteca OpenZeppelin, que ofrece un conjunto de contratos inteligentes auditados y aprobados por su comunidad.

Aunque Solidity no sea el único lenguaje de programación destinado a la creación de Smart Contracts, mi preferencia por este lenguaje se fundamente en dos aspectos claves.
En primer lugar, mi familiaridad previa con lenguajes como JavaScript y python hace que la transición a Solidity sea más intuitiva, a diferencia de Vyper cuya sintaxis presentan mayores diferencias.
Por otro lado, uno de los requisitos fundamentales de este proyecto era la capacidad del lenguaje para soportar herencia, una característica fundamental para implementar el estándar ERC-721, requisito que Vyper no incluye.


\subsection{Remix}

Remix es un entorno de desarrollo integrado (IDE) diseñado para el desarrollo de Smart Contracts escritos en Solidity. Proporciona una interfaz accesible y amigable para escribir, compilar, probar y desplegar Smart Contracts directamente desde el navegador, sin la necesidad de instalar software adicional.
Remix también ofrece funcionalidades avanzadas como la compilación en tiempo real, el despliegue de contratos en diversas redes de prueba (testnets) y la interacción con SmartContracts ya desplegados.
Una de las características más útiles de este IDE es su análisis estático del código, pudiendo así identificar posibles errores de programación o vulnerabilidades de seguridad. Crucial para el desarrollo de Smart Contracts donde los errores pueden suponer consecuencias financieras significativas.

Además, Remix se integra con herramientas y plugins adicionales, ofreciendo un entorna mas rico y extenso permitiendo conectarse con herramientas y servicios como MetaMask, Truffle y Ganache los cuales han sido de gran utilidad en mi proyecto.
Remix ha tenido una gran protagonismo en el desarrollo de mi proyecto permitiéndome iterar rápidamente a través de diferentes versiones de contratos inteligentes. Pudiendo ejecutar pruebas unitarias con diversas redes Ethereum como Rinkeby y Goerli, indispensable para validar la lógica del Smart Contract antes de su despliegue final. Dándome una gran capacidad de testeo en un entorno controlado pero realista el cual ha sido crucial para la corrección de errores y la optimización del uso de gas, asegurando así la eficiencia y seguridad de los contratos inteligentes desarrollados.


\subsection{Infura}

Infura es una plataforma que proporciona una API escalable y de alta disponibilidad para acceder a la Blockchain de Ethereum, entre muchas otras.
Esta plataforma permite desplegar contratos inteligentes en la Blockchain sin necesidad de mantener un nodo propio lo que representa un ahorro significativo en timpo y recursos.
Para ello, Infura proporciona "endPoints" de API que facilitan la lecutra y escritura de datos en la Blockchain.
Infura es una propuesta de gran valor para el desarrollo de dApps como la presente, ya que facilita el despliegue y la interacción de contratos inteligentes, asegurando una alta disponibilidad. Esto garantiza que las aplicaciones puedan realizar y recibir transacciones en cualquier momento.
Del mismo modo, a medida que el proyecto crece, Infura se adapta a las necesidades de escalabilidad, permitiendo que la aplicación pueda manejar un mayor número de solicitudes de manera eficiente.


\subsection{Truffle}

Tras una fase inicial de desarrollo de los Smart Contracts usando Remix, la transición al uso de Truffle ha marcado un punto de inflexión en la complejidad de mi proyecto.
Truffle consiste en una suite de desarrollo avanzada para Ethereum, ofreciendo un conjunto de herramientas diseñadas para facilitar el desarrollo, gestión y despliegue de Smart Contracts.
Truffle ofrece un entorno de desarrollo estructurado generando una jerarquía de carpetas para favorecer la implementación de proyectos blockchain complejos.
Ahorra mucho tiempo con su sistema de migraciones y scripts de despliegue el cual automatiza y simplifica el proceso de lanzamiento de contratos.

Aunque Remix es una excelente herramienta, Truffle eleva la posibilidad de hacer pruebas unitarias a otro nivel con un marco de prueba mucho mas sofisticado, permitiendo ejecutar test en Solidity o JavaScript.Esta capacidad ampliada para realizar pruebas unitarias contribuye de manera crucial a la calidad y seguridad del código de los Smart Contracts.

Finalmente, uno de las mayores ventajas de usar Truffle en el desarrollo de aplicaciones descentralizadas es en cómo simplifica el proceso de unir el trabajo que se realiza en el backend con el frontend. Truffle proporciona herramientas que que promueven una conexión mas directa y menos propensa a errores entre Smart Contracts y las aplicaciones móviles.


\subsection{Ganache}

Ganache funciona como un nodo de Ethereum personal, permitiendo a los desarrolladores simular un entorno de blockchain que opera localmente ofreciendo un espacio seguro y controlado para experimentar sin ningún costo real ni tiempos de espera al contrario que pasa con las redes públicas de Ethereum.
Por defecto, proporciona diez cuentas cargadas con 1000 ETH cada una junto con sus correspondientes claves públicas y privadas, aunque esta configuración puede ajustarse según las necesidades del proyecto.

Disponible tanto como una herramienta en línea de comandos o como una aplicación de escritorio. Ganache proporciona  una vista de las transacciones, bloques y estado de la red, mostrando el feedback en tiempo real, vital para realizar una iteración rápida.

La integración de Ganache con Truffle facilita aún más su utilidad, estableciéndose como el entorno de desarrollo local predeterminado dentro del ecosistema Truffle.
De esta forma se permite testear la eficiencia de los contratos ajustando parámetros como el tiempo de bloque para simular diferentes condiciones de red.


\subsection{MetaMask}

MetaMask es una extensión de navegador y una aplicación móvil que permite a los usuarios interactuar con la blockchain de manera segura y sencilla. Actúa como puente entre los navegadores web y la blockchain.
Su funcionamiento es análogo a una cartera digital, permitiendo a los usuarios almacenar sus cuentas de Ethereum así como el envío de criptomonedas.

Al conectarse a dApps, los usuarios pueden usar sus cuentas de MetaMask para autenticarse eliminando la necesidad de ingresar claves privadas manualmente. Por otro lado, aplica una capa adicional de seguridad al encriptar la información del usuario y almacenar las claves privadas directamente en el dispositivo del usuario. Esto asegura que solo el usuario tenga acceso a sus fondos y datos.

La integración de MetaMask en mi proyecto no solo mejora la experiencia del usuario final,
proporcionando una forma más segura e intuitiva de acceder a sus activos, sino que también agiliza el desarrollo de mi proyecto al simplificar la manera en que los usuarios se conectan a la dApp.

Finalmente una característica definitiva de Metamask a diferencia de otras billeteras, es su capacidad para agregar redes personalizadas, de gran utilidad para el testeo de la aplicación, permitiendo la conexión a entornos específicos como el entorno local proporcionado por Ganache o la tesnet de Sepolia.


\subsection{Node.js}

Node.js es un entorno de ejecución en JavaScript, que tradicionalmente ha sido un lenguaje de programación del lado del cliente, para desarrollar aplicaciones del lado del servidor. Es conocido por su capacidad para manejar operaciones asíncronas y por su escalabilidad siendo de gran popularidad en el desarrollo de aplicaciones web modernas. Una de las ventajas de de Node.js es su ecosistema de paquetes gestionados por npm (Node Package Manager), que proporciona acceso a miles de librerías.

En el proyecto se ha usado de manera frecuente, más allá de ser un requisito para utilizar Truffle, a través del comando \"npm install\" para descargar librerías y paquetes necesarios tanto para el desarrollo del frontend como el del backend.
Bien es así, que aunque React Native sea el framework principal del desarrollo del frontend, la gestión de sus dependencias, librerías adicionales se realiza mediante npm, el cual opera sobre Node.js.
Por ejemplo el uso de la biblioteca \"Ethers\", una de las mas importantes del proyecto ya que es fundamental para interactuar con la blockchain, se ha instalado y gestionado usando npm.
Por tanto, Node.js ha sido una pieza crucial en el desarrollo del proyecto, demostrando su valor no solo como una plataforma de desarrollo del lado del servidor, sino también como un eje central para la administración de paquetes y librerías en el desarrollo de aplicaciones completas.


\subsection{EtherScan}

EtherScan ofrece una plataforma web que permite explorar los bloques de la red de Ethereum.
Esta herramienta permite seguir la actualización de la red Ethereum en tiempo real, observando cómo se añaden nuevos bloques y el conjunto de transacciones de cada uno. También permite buscar específicamente una transacción que se ha cometido a lo largo del tiempo mediante su función hash.
A parte de mostrar las transacciones en tiempo real, EtherScan permite desglosar cada transacción para ofrecer detalles como el número de bloque, la hora exacta de la confirmación, y datos específicos sobre las acciones dentro de las transacción, tales como transferencias de tokenes ERC-721, el valor transferido, las tarifas de gas, etcétera.
EtherScan también sirve como un centro de análisis, en su plataforma podemos encontrar información relevando sobre el estado de la red, cómo estadísticas en tiempo real y datos históricos sobre la dificultad del minado, el precio del gas y otras métricas que pueden ser da gran utilidad para entender el comportamiento de la app en un momento determinado.
EtherScan ha tenido un gran protagonismo en la etapa final de mi aplicación donde se ha desplegado el contrato inteligente en una red real de prueba.
Con esta herramienta se ha monitoreado la ejecución y rendimiento del contrato, asegurando su correcto funcionamiento y fiabilidad.
Por otro lado, ha permitido experimentar y observar la eficiencia del contrato dependiendo de las fluctuaciones en el precio del gas y otras condiciones de la red.


\subsection{Sepolia PoW Faucet}

En las primeras implementaciones del proyecto se ha utilizado ETH ficticios que se generaban en un contexto local, pero en las versiones finales del proyecto y en su despliegue en una red de prueba real ha sido necesario obtener ETH de prueba reales para poder interaccionar con la Blockchain.
Al ser ETH de prueba, estos carecen de valor y por lo tanto no se pueden comprar como se haría con ETH de la mainnet, por lo tanto las únicas formas de conseguirlos es minando o que otro usuario te los proporcione.
Convertirse en un minero para obtener ETH de prueba es una opción más compleja, por lo que el uso de las faucet reduce en gran cantidad esta barrera de entrada.

Existen diversas faucets que proveen una cantidad de ETH de prueba diaria, pero en la mayoría para verificar la autenticidad del usuario se requiere que dicho usuario cuente con una pequeña cantidad de ETH reales en su billetera y por lo tanto obligan a hacer una pequeña inversión.
Sin embargo, existe una faucet llamada Sepolia PoW Faucet que verifica la autenticidad del usuario mediante el mecanismo de prueba de trabajo (PoW), eliminando la necesidad de poseer ETH reales.
Este enfoque requiere que los usuarios realicen un trabajo de cómputo, específicamente generando hashes que cumplan con ciertos criterios preestablecidos, para demostrar su esfuerzo y recibir ETH de prueba a cambio. 


\section{Bibliotecas}

Se muestra a continuación las bibliotecas usadas a lo largo del desarrollo del proyecto.

\subsection{OpenZeppelin}

OpenZeppelin es una biblioteca para el desarrollo seguro de Smart Contracts en Ethereum. Ofrece implementaciones auditadas y probadas para minimizar riesgos de seguridad.
Su uso ha sido crucial para el desarrollo de mi proyecto, usando el estándar ERC721 para la representación de los contratos como tokens no fungibles (NFTs) asegurando que la aplicación cumpla con los estándares de seguridad.

